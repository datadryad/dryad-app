<%# local variable resource %>

<%# these are to set some things that change because we have multiple models for different types of files, will rework when
 # we have all going into one model with a "type" of file %>

<% rails_presign_url = (@file_model == StashEngine::SoftwareFile ? software_file_presign_url_path(resource) :
                      data_file_presign_url_path(resource) )%>

<% complete_path = (@file_model == StashEngine::SoftwareFile ? software_file_complete_path(resource) :
                       data_file_complete_path(resource) ) %>

<% s3_directory = resource.s3_dir_name(type: (@file_model == StashEngine::SoftwareFile ? 'software' : 'data')) %>

/* Based on https://lea.verou.me/2016/12/resolve-promises-externally-with-this-one-weird-trick/
   It keeps files uploading one at a time in evaporateIt function by not fulfilling promise until the
   the file is complete.  Keeps most of the configuration intact without a lot of rewriting.

   May revisit later as we move to reworking the uploads more in another framework.  This example is
   more promise-like.

   https://github.com/TTLabs/EvaporateJS/blob/master/example/evaporate_example.html
 */

function deferPromise() {
  var res, rej;

  var promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });

  promise.resolve = res;
  promise.reject = rej;

  return promise;
}

function evaporateIt(key, complexFileObj) {

  let allDone = deferPromise();

  fileObj = complexFileObj["fileObj"]
  sanitized_fn = complexFileObj["sanitized"]
  // see example like https://github.com/TTLabs/EvaporateJS/blob/c1f8905d173f07dab1f277b4bd753a2ce2303967/example/evaporate_example_awsv4_signature.html
  const config = {
    signerUrl: "<%= rails_presign_url %>",
    aws_key: "<%= APP_CONFIG[:s3][:key] %>",
    bucket: "<%= APP_CONFIG[:s3][:bucket] %>",
    awsRegion: "<%= APP_CONFIG[:s3][:region] %>",
    awsSignatureVersion: '4',
    computeContentMd5: true,
    cryptoMd5Method: data => { return AWS.util.crypto.md5(data, 'base64'); },
    cryptoHexEncodedHash256: data => { return AWS.util.crypto.sha256(data, 'hex'); }
  };

  const md5Id = Crypto.createHash('MD5').update(fileObj.name).digest('hex');

  const uploadFile = evaporate => {

    const addConfig = {
      name: "<%= s3_directory %>" + "/" + sanitized_fn,
      file: fileObj,
      contentType: fileObj.type,
      progress: progressValue => {
        $('#progress_' + key).attr('value', progressValue);
      },
      cancelled: function () {
        allDone.reject();
      },
      error: function (msg) {
        allDone.reject();
      },
      complete: (_xhr, awsKey) => {
        $.ajax({
          type: "POST",
          url: "<%= complete_path %>",
          contentType: 'application/json; charset=utf-8',
          data: JSON.stringify(
              {
                resource_id: "<%= @resource.id %>",
                name: sanitized_fn,
                size: fileObj.size,
                type: fileObj.type,
                original: fileObj.name
              }
          ),
          success: result => {
            $("#progress_" + key).replaceWith("<span>Complete</span>");
            $("#cancel_" + key).hide();
            fUploading.delete(key);
            allDone.resolve();
          },
          error: result => {
            var myObj = JSON.parse(result.responseText)
            console.log(myObj["msg"]);
            allDone.reject();
          },
          dataType: 'json'
        });
      }
    }

    // The bucket and some other properties may want to be be changed per upload
    const overrides = {
      bucket: "<%= APP_CONFIG[:s3][:bucket] %>"
    };

    evaporate.add(addConfig, overrides)
        .then(
            awsObjectKey => console.log('File successfully uploaded to:', awsObjectKey),
            reason => console.log('File did not upload sucessfully:', reason)
        );
  }

  Evaporate.create(config).then(uploadFile);
  return allDone;  // a promise that it has uploaded or failed and will wait to complete if a .then is placed after
}